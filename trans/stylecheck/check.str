module stylecheck/check

imports
	
	include/C
	stylecheck/core
	lib/runtime/editor/origins
	
rules // Name checks
	
	check-name-gt(|max, kind):
		name -> name
		where
			length := <strlen> name;
			<gt> (length, max);
			<create-error(|name)> $[[<first-upper> kind] may not be more than [max] characters long]
			
	check-name-lt(|max, kind):
		name -> name
		where
			length := <strlen> name;
			<lt> (length, max);
			<create-error(|name)> $[[<first-upper> kind] must be at least [max] characters long]

	check-name-starts-with(|string, kind):
		name -> name
		where
			not(<string-starts-with(|string)> name);
			<create-error(|name)> $[[<first-upper> kind] must start with the character(s) '[string]']

	check-name-is-uppercase(|position, kind):
		name -> name
		where
			<not(explode-string; index(|position); is-upper)> name;
			<create-error(|name)> $[Character [position] of a [kind] must be upper case]
			
	check-name-is-lowercase(|position, kind):
		name -> name
		where
			<not(explode-string; index(|position); is-lower)> name;
			<create-error(|name)> $[Character [position] of a [kind] must be lower case]

rules // Ordering checks
	
	check-comes-before(before, after|before-name, after-name):
		list -> <id>
		where
			first := <Hd> list;
			<find(after, before)> list;
			<create-error(|first)> $[[<first-upper> before-name] must come before [after-name].]
			
	find(before, after):
		[x|xs] -> r  
		where
			<before> x;
			r := <fetch-elem(after)> xs
			
	find(before, after):
		[x|xs] -> <find(before, after)> xs
		where
			<before> x;
			<not(collect-one(after))> xs
			
	find(before, after):
		[x|xs] -> <find(before, after)> xs
		where
			<not(before)> x
			
	find(before, after):
		[] -> <fail>

	check-ordering(s1, s2|t1, t2):
		list -> <id>
		where
			<try(check-comes-before(s1, s2|t1, t2))> list
		
	check-ordering(s1, s2, s3|t1, t2, t3):
		list -> <id>
		where
			<try(check-comes-before(s1, s2|t1, t2))> list
		; <try(check-comes-before(s1, s3|t1, t3))> list
		; <try(check-comes-before(s2, s3|t2, t3))> list
		  
	check-ordering(s1, s2, s3, s4|t1, t2, t3, t4):
		list -> <id>
		where
			<try(check-comes-before(s1, s2|t1, t2))> list
		; <try(check-comes-before(s1, s3|t1, t3))> list
	  ; <try(check-comes-before(s1, s4|t1, t4))> list
		; <try(check-comes-before(s2, s3|t2, t3))> list
	  ; <try(check-comes-before(s2, s4|t2, t4))> list
		; <try(check-comes-before(s3, s4|t3, t4))> list
		  
	check-ordering(s1, s2, s3, s4, s5|t1, t2, t3, t4, t5):
		list -> <id>
		where
			<try(check-comes-before(s1, s2|t1, t2))> list
		; <try(check-comes-before(s1, s3|t1, t3))> list
	  ; <try(check-comes-before(s1, s4|t1, t4))> list
		; <try(check-comes-before(s1, s5|t1, t5))> list
		; <try(check-comes-before(s2, s3|t2, t3))> list
	  ; <try(check-comes-before(s2, s4|t2, t4))> list
		; <try(check-comes-before(s2, s5|t2, t5))> list
		; <try(check-comes-before(s3, s4|t3, t4))> list
		; <try(check-comes-before(s3, s5|t3, t5))> list
		; <try(check-comes-before(s4, s5|t4, t5))> list
	
rules // Spacing/tab checks
	
	check-indentation(|level, kind):
		term -> <id>
		where
			level-mult := <check-indentation-multiplier <+ !level> level;
			(_, start-col, _, _) := <origin-location> term;
			<not(eq)> (start-col, level-mult);
			<create-error(|term)> $[Needs to be at indentation level [level].]
			
	check-indentation-multiplier = fail
	
rules // Line feed checks
	
rules // Util
	
	first-upper =
		explode-string; [to-upper|id]; implode-string
		